<?xml version="1.0" encoding="utf-8"?>
<topic id="52e40f26-3dfe-47e0-adf1-09233e98f42e" revisionNumber="1">
  <developerConceptualDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink">
    <introduction>
      <para>
        This is a quick tutorial to learn how to use <token>projectName</token>
      </para>
    </introduction>

    <section>
      <title>Index of contents</title>
      <content>
        <list bullet="class">
          <listItem>
            <link xlink:href="#objects2trackable">How to turn objects into change-trackable ones</link>
          </listItem>
          <listItem>
            <link xlink:href="#changedPropertyChecking">Checking which properties have been changed</link>
          </listItem>
          <listItem>
            <link xlink:href="#oldValue">Getting the value of some property before it was changed</link>
          </listItem>
          <listItem>
            <link xlink:href="#currentValue">Getting current property value</link>
          </listItem>
          <listItem>
            <link xlink:href="#propertyChanged">Checking if a property changed its value since it was started to be tracked</link>
          </listItem>
          <listItem>
            <link xlink:href="#undo">How do I accept or undo changes</link>
          </listItem>
          <listItem>
            <link xlink:href="#collectionChanges">Tracking collection changes</link>
          </listItem>
          <listItem>
            <link xlink:href="#graph">Object graph changes</link>
          </listItem>
          <listItem>
            <link xlink:href="#observe">Observe property and collection changes</link>
          </listItem>
          <listItem>
            <link xlink:href="#dynamic">Track dynamic objects</link>
          </listItem>
          <listItem>
            <link xlink:href="#test">Read the tests too</link>
          </listItem>
        </list>
      </content>
    </section>

    <section address="objects2trackable">
      <title>How to turn objects into change-trackable ones</title>
      <content>
        <para>
          First of all, you need to design a regular class. <legacyBold>
            Note that the class must not be sealed and
            its properties must be <newTerm>virtual</newTerm> to let the proxy generator override them to intercept both
            sets and gets:
          </legacyBold>
        </para>
        <code language="c#">
          <![CDATA[
              public class User
              {
                public virtual string Name { get; set; }
                public virtual byte Age { get; set; }
              }
              ]]>
        </code>
        <para>
          Before being able to turn an object into a change-trackable one, you will need to tell <token>projectName</token> that
          your class (i.e. <phrase>the type</phrase>) can be trackable:
        </para>
        <code language="c#">
          <![CDATA[TrackerDogConfiguration.TrackTheseTypes(Track.ThisType<User>());]]>
        </code>
        <para>
          Above configuration will tell <tokenName>TrackerDog</tokenName> to track all property changes for the given type. <legacyBold>
            This can
            be harmful and it's advisable that you tell <tokenName>TrackerDog</tokenName> which properties you want to track for the given type:
          </legacyBold>
        </para>
        <code language="c#">
          <![CDATA[
          // This will avoid some overhead since TrackerDog won't need to intercept absolutely all
          // property changes
          TrackerDogConfiguration.TrackTheseTypes
          (
              Track.ThisType<User>().TrackProperties(u => u.Name, u => u.Age)
          );
          ]]>
        </code>
        <para>
          Now, to track an instance of <codeInline>User</codeInline> you need to
          use <codeEntityReference>M:TrackerDog.ObjectChangeTrackingExtensions.AsTrackable``1(``0)</codeEntityReference> extension method:
        </para>
        <code language="c#">
          <![CDATA[
              User user = new User().AsTrackable();
              
              // or...
              User user = new User();
              user = user.AsTrackable();
              
              // Also you can create a trackable object from the type directly:
              User user2 = Trackable.Of<User>();
              ]]>
        </code>
        <para>
          Note that you won't be able to create trackable objects using <codeEntityReference>M:TrackerDog.ObjectChangeTrackingExtensions.AsTrackable``1(``0)</codeEntityReference>
          extension method if the whole object type has no paramterless constructor. Either if it has both a parameterless constructor or a one with parameters, and you want to create a trackable
          object with constructor arguments, you'll need to use <codeEntityReference>M:TrackerDog.Trackable.Of``1(System.Object[])</codeEntityReference> method:
        </para>
        <code language="c#">
          <![CDATA[
            public class A 
            {
              public A() { }
              public A(int a, string b) { }
            }
            
            TrackerDogConfiguration.TrackTheseTypes(Track.ThisType<User>());
            
            A a1 = new A().AsTrackable(); // Regular way
            A a2 = Trackable.Of<A>(); // From type with parameterless constructor
            A a3 = Trackable.Of<A>(101, "hello world"); // From type with constructor which has parameters
          ]]>
        </code>
        <para>Now you can produce changes to the trackable object:</para>
        <code language="c#">
          <![CDATA[
            user.Name = "Matías";
            user.Age = 30;
            ]]>
        </code>
      </content>
    </section>

    <section address="changedPropertyChecking">
      <title>Checking which properties have been changed</title>
      <content>
        <para>
          Call <codeEntityReference>M:TrackerDog.ObjectChangeTrackingExtensions.GetChangeTracker(System.Object)</codeEntityReference> extension method:
        </para>
        <code language="c#">
          <![CDATA[
            IObjectChangeTracker changeTracker = user.GetChangeTracker();
            
            IImmutableSet<IObjectPropertyChangeTracking> changedProperties = changeTracker.ChangedProperties;
            
            // Also you can get unchanged properties
            IImmutableSet<IObjectPropertyChangeTracking> unchangedProperties = changeTracker.UnchangedProperties;
            ]]>
        </code>
        <para>
          This will give sets of changed and unchanged properties typed as <codeEntityReference>T:TrackerDog.IObjectPropertyChangeTracking</codeEntityReference>. Mostly this
          is fine, but the whole interface exposes the affected property as string. If you need further info to perform reflection operations, you should cast set elements to
          <codeEntityReference>T:TrackerDog.IDeclaredObjectPropertyChangeTracking</codeEntityReference>:
        </para>
        <code language="c#">
          <![CDATA[
          IEnumerable<IObjectPropertyChangeTracking> changedProperties = changeTracker.ChangedProperties.Of<IDeclaredObjectPropertyChangeTracking>();
            
          // Also you can get unchanged properties
          IEnumerable<IObjectPropertyChangeTracking> unchangedProperties = changeTracker.UnchangedProperties.Of<IDeclaredObjectPropertyChangeTracking>();
          ]]>
        </code>
        <para>
          Now you'll be able to access <codeEntityReference>P:TrackerDog.IDeclaredObjectPropertyChangeTracking.Property</codeEntityReference>.
        </para>
        <para>
          Since <codeEntityReference>T:TrackerDog.IDeclaredObjectPropertyChangeTracking</codeEntityReference> also implements <codeEntityReference>T:TrackerDog.IObjectPropertyChangeTracking</codeEntityReference>, unless
          you need the property info of tracked property, there's no need to perform the whole cast.
        </para>
      </content>
    </section>

    <section address="oldValue">
      <title>Getting the value of some property before it was changed</title>
      <content>
        <para>
          Call <codeEntityReference>M:TrackerDog.ObjectChangeTrackingExtensions.OldPropertyValue``2(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}})</codeEntityReference> extension method:
        </para>
        <code language="c#">
          <![CDATA[
            string oldUserName = user.OldPropertyValue(u => u.Name);
            
            // You can also get a property tracking object
            IObjectChangeTracking userNameChangeTracking = user.GetPropertyTracking(u => u.Name);
            
            oldUserName = userNameChangeTracking.OldValue;
            ]]>
        </code>
      </content>
    </section>

    <section address="currentValue">
      <title>Getting current property value</title>
      <content>
        <para>
          Call <codeEntityReference>M:TrackerDog.ObjectChangeTrackingExtensions.CurrentPropertyValue``2(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}})</codeEntityReference> extension method:
        </para>
        <code language="c#">
          <![CDATA[
            string currentUserName = user.CurrentPropertyValue(u => u.Name);
            
            // Ok, you would also be able to achieve the same result doing so:
            currentUserName = user.Name;
            
            // But having this method lets you build an expression tree to select some tracked property "current value"...
            
            // You can also get a property tracking object
            IObjectChangeTracking userNameChangeTracking = user.GetPropertyTracking(u => u.Name);
            
            currentUserName = userNameChangeTracking.CurrentValue;
            ]]>
        </code>
      </content>
    </section>

    <section address="propertyChanged">
      <title>Checking if a property changed its value since it was started to be tracked</title>
      <content>
        <para>
          Call <codeEntityReference>M:TrackerDog.ObjectChangeTrackingExtensions.PropertyHasChanged``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Object}})</codeEntityReference> extension method:
        </para>
        <code language="c#">
          <![CDATA[
            if(user.PropertyHasChanged(u => u.Name))
            {
                // It has changed!
            }
            
            // You can also get a property tracking object
            IObjectChangeTracking userNameChangeTracking = user.GetPropertyTracking(u => u.Name);
            
            if(userNameChangeTracking.HasChanged)
            {
                // It has changed!
            }
            ]]>
        </code>
      </content>
    </section>

    <section address="undo">
      <title>How do I accept or undo changes</title>
      <content>
        <para>
          Call
          <codeEntityReference>M:TrackerDog.ObjectChangeTrackingExtensions.AcceptChanges(System.Object)</codeEntityReference> or
          <codeEntityReference>M:TrackerDog.ObjectChangeTrackingExtensions.UndoChanges(System.Object)</codeEntityReference> extension methods:
        </para>
        <code language="c#">
          <![CDATA[
            user.AcceptChanges();
            
            // or...
            user.UndoChanges();
            ]]>
        </code>
      </content>
    </section>

    <section address="collectionChanges">
      <title>Tracking collection changes</title>
      <content>
        <code language="c#">
          <![CDATA[
          public class App 
          {
              public virtual List<User> Users { get; } = new List<User>();
          }
          
          public class User 
          {
              public string Name { get; set; }
              public byte Age { get; set; }
          }
          
          App app = new App().AsTrackable();
          app.Users.Add(new User { Name = "Matías", Age = 30 });
          
          IReadOnlyChangeTrackableCollection trackableCollection =
                        (IReadOnlyChangeTrackableCollection)app.CurrentPropertyValue(app => app.Users);
                        
          IImmutableSet<object> addedItems = trackableCollection.AddedItems;
          IImmutableSet<object> removedItems = trackableCollection.RemovedItems;
          
          // If you need typed items...
          IEnumerable<User> typedAddedUsers = addedItems.Cast<User>();
          IEnumerable<User> typedRemovedUsers = removedItems.Cast<User>();
          ]]>
        </code>
        <para>
          Don't forget to add both <codeInline>App</codeInline> and <codeInline>User</codeInline> class as
          trackable types:
        </para>
        <code language="c#">
          <![CDATA[
          TrackerDogConfiguration.TrackTheseTypes
          (
              Track.ThisType<App>().IncludeProperty(app => app.Users),
              Track.ThisType<User>().IncludeProperties(user => user.Name, user => user.Age)
          );
          ]]>
        </code>
      </content>
    </section>

    <section address="graph">
      <title>Object graph changes</title>
      <content>
        <para>
          When an aggregate root has many associations like 1-n, 1-1 or even M-N, <token>projectName</token>
          works the same way as a POCO with no associations with other objects:
        </para>
        <code language="c#">
          <![CDATA[
          public class A
          {
              public virtual string Text { get; set; }
              public virtual B B { get; set; }
          }

          public class B
          {
              public virtual string Text { get; set; }
              public virtual C C { get; set; }
          }

          public class C
          {
              public virtual string Text { get; set; }
              public virtual IList<D> ListOfD { get; set; }
          }

          public class D
          {
              public virtual string Text { get; set; }
          }
          
          // It will track the full object graph changes!
          A a = new A
          {
            Text = initialValue,
            B = new B
            {
                Text = initialValue,
                C = new C
                {
                    Text = initialValue,
                    ListOfD = new List<D> { new D { Text = "initialValue" } }
                }
            }
          }.AsTrackable();
          ]]>
        </code>
        <para>
          Don't forget to add all types as trackable types:
        </para>
        <code language="c#">
          <![CDATA[
          TrackerDogConfiguration.TrackTheseTypes
          (
              Track.ThisType<A>().IncludeProperties(a => a.Text, a => a.B),
              Track.ThisType<B>().IncludeProperties(b => b.Text, b => b.C),
              Track.ThisType<C>().IncludeProperties(c => c.Text, c => c.ListOfD),
              Track.ThisType<D>().IncludeProperty(d => d.Text)
          );
          ]]>
        </code>
      </content>
    </section>

    <section address="observe">
      <title>Observe property and collection changes</title>
      <content>
        <para>
          All change-tracked objects implement <codeEntityReference>T:System.ComponentModel.INotifyPropertyChanged</codeEntityReference> and
          change-tracked collection properties implement <codeEntityReference>T:System.Collections.Specialized.INotifyCollectionChanged</codeEntityReference>.

        </para>
        <para>
          Note that collection changes will also trigger a <codeEntityReference>E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged</codeEntityReference> event on the
          object in the other side of the 1-n association.

        </para>
        <code language="c#">
          <![CDATA[
          public class App 
          {
              public virtual string Name { get; set; }
              public List<User> Users { get; } = new List<User>();
          }
          
          public class User 
          {
              public virtual string Name { get; set; }
              public virtual byte Age { get; set; }
          }
          
          App app = new App().AsTrackable();
          
          ((INotifyPropertyChanged)app).PropertyChanged += (sender, e) =>
          {
              string propertyName = e.PropertyName;
          };
          
          ((INotifyCollectionChanged)app.Users).CollectionChanged += (sender, e) =>
          {
              IEnumerable<object> changedItems = e.ChangedItems;
          };
          
          app.Name = "MyApp"; // This will trigger a PropertyChanged event on app
          
           // This will both trigger a CollectionChanged event on app.Users and a PropertyChanged event on
           // app.
          app.Users.Add(new User { Name = "Matías" });
          ]]>
        </code>
        <para>
          Don't forget to add all types as trackable types:
        </para>
        <code language="c#">
          <![CDATA[
          TrackerDogConfiguration.TrackTheseTypes
          (
              Track.ThisType<App>().IncludeProperty(app => app.Name, app => app.Users),
              Track.ThisType<User>().IncludeProperties(user => user.Name, user => user.Age)
          );
          ]]>
        </code>
      </content>
    </section>

    <section>
      <title>Track dynamic objects</title>
      <content>
        <para>
          A dynamic object (i.e. a derived class of <codeEntityReference>T:System.Dynamic.DynamicObject</codeEntityReference>) can't be tracked
          <phrase>per se</phrase>. For example, <codeEntityReference>T:System.Dynamic.ExpandoObject</codeEntityReference> can't be tracked because
          it's a sealed class and either way its members aren't virtual.
        </para>
        <para>
          <token>projectName</token> supports dynamic objects but they must be non-sealed class and their members must be virtual. That is, <token>projectName</token>
          will be able to track custom dynamic objects. For example:
        </para>
        <code language="c#">
          <![CDATA[
          public class TestDynamicObject : DynamicObject
          {
              private string value;

              public override bool TryGetMember(GetMemberBinder binder, out object result)
              {
                  result = value;

                  return true;
              }

              public override bool TrySetMember(SetMemberBinder binder, object value)
              {
                  this.value = value?.ToString();
                  return true;
              }
          }
          ]]>
        </code>
        <para>
          Above class has no sense in a real-world case, since any try to set a member sets the same class field
          and whenever any member is tried to be got, it will return the last set value. But this sample dynamic object
          is a good enough to test that <token>projectName</token> can track dynamic objects:
        </para>
        <code language="c#">
          <![CDATA[
          TrackerDogConfiguration.TrackTheseTypes
          (
              Track.ThisType<TestDynamicObject>()
          );
          
          dynamic trackable = new TestDynamicObject().AsTrackable();
          trackable.Text = "hello world";
          trackable.Text = "hello world2";
          ]]>
        </code>
        <para>
          Now the issue will be using <codeEntityReference>M:TrackerDog.ObjectChangeTrackingExtensions.AsTrackable``1(``0)</codeEntityReference> with a dynamic object.
          You'll need to cast the <literal>dynamic</literal>-typed variable into <literal>object</literal> to be able to call all object change tracking-related extension methods:
        </para>
        <code language="c#">
          <![CDATA[
          // Note that all extension methods that relate to dynamic objects will require
          // you to give the property name as string, because expression trees can't work with 
          // dynamic objects, and anyway, "Text" property doesn't exist since it's not declared but
          // dynamically-handled using DynamicObject.TryGetMemeber and DynamicObject.TrySetMember
          string currentTextValue = ((object)trackable).OldPropertyValue("Text");
          IObjectChangeTracker changeTracker ((object)trackable).GetChangeTracker();
          // ...and so on.
          ]]>
        </code>
        <para>
          When getting property trackings, there's a difference between <phrase>declared properties</phrase> and <phrase>dynamic properties</phrase>
        </para>
        <list class="bullet">
          <listItem>
            ...when you want a tracking of a declared property (i.e. a design-time declared property), you'll get a <codeEntityReference>T:TrackerDog.IDeclaredObjectPropertyChangeTracking</codeEntityReference>, and it
            will provide access you to the <codeEntityReference>P:TrackerDog.IDeclaredObjectPropertyChangeTracking.Property</codeEntityReference> which is of type <codeEntityReference>T:System.Reflection.PropertyInfo</codeEntityReference>.
          </listItem>
          <listItem>
            ...when you want a tracking of a dynamic property (i.e. a run-time added property), you'll get a <codeEntityReference>T:TrackerDog.IObjectPropertyChangeTracking</codeEntityReference>, and it
            will provide access you to the <codeEntityReference>P:TrackerDog.IObjectPropertyChangeTracking.PropertyName</codeEntityReference> which provides less info than a <codeEntityReference>T:System.Reflection.PropertyInfo</codeEntityReference> since
            the property belongs to the object where it was declared but <phrase>since it's not an actual property, you don't know more than just its name</phrase>.
          </listItem>
        </list>
        <para>
          For example, if you want to get a dynamic property tracking, you would do as follows:
        </para>
        <code language="c#">
          <![CDATA[
          IObjectChangeTracker changeTracker ((object)trackable).GetChangeTracker();
          IObjectPropertyChangeTracking propertyTracking = tracker.GetDynamicTrackingByProperty("Text");
          ]]>
        </code>
      </content>
    </section>

    <section address="test">
      <title>Read the tests too</title>
      <content>
        <para>
          In addition to this tutorial, you might learn more reading the unit/integration tests provided as part
          of project's source code. You can also clone the repository in your own computer and run the whole tests using
          the Visual Studio debugger to check how <token>projectName</token> works step by step!
        </para>
        <list class="bullet">
          <listItem>
            <externalLink>
              <linkText>GitHub repository</linkText>
              <linkUri>https://github.com/mfidemraizer/trackerdog</linkUri>
            </externalLink>.
          </listItem>
          <listItem>
            <externalLink>
              <linkText>Tests source code</linkText>
              <linkUri>https://github.com/mfidemraizer/trackerdog/tree/master/TrackerDog.Test</linkUri>
            </externalLink>.
          </listItem>
        </list>
      </content>
    </section>
    
    <relatedTopics>
      <link xlink:href="1e03762d-b9f5-44af-a4b0-c23c36064c24" />
    </relatedTopics>
  </developerConceptualDocument>
</topic>