<?xml version="1.0" encoding="utf-8"?>
<topic id="52e40f26-3dfe-47e0-adf1-09233e98f42e" revisionNumber="1">
  <developerConceptualDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink">
    <introduction>
      <para>
        This is a quick tutorial to learn how to use <token>projectName</token>
      </para>
    </introduction>

    <section>
      <title>Index of contents</title>
      <content>
        <list class="bullet">
          <listItem>
            <para>
              <link xlink:href="#objects2trackable">How to turn objects into change-trackable ones</link>
            </para>
          </listItem>
          <listItem>
            <para>
              <link xlink:href="#inheritance">How to track inheritance</link>
            </para>
          </listItem>
          <listItem>
            <para>
              <link xlink:href="#assemblyConfiguration">Configuring all types from a given assembly</link>
            </para>
          </listItem>
          <listItem>
            <para>
              <link xlink:href="#attributeConfiguration">Attribute-based configuration</link>
            </para>
          </listItem>
          <listItem>
            <para>
              <link xlink:href="#recursiveConfiguration">Recursively-configuring trackable types</link>
            </para>
          </listItem>
          <listItem>
            <para>
              <link xlink:href="#trackingInterfaces">How to track interface implementation changes</link>
            </para>
          </listItem>
          <listItem>
            <para>
              <link xlink:href="#objects2untrackable">How to turn trackable objects into untrackable objects</link>
            </para>
          </listItem>
          <listItem>
            <para>
              <link xlink:href="#changedPropertyChecking">Checking which properties have been changed</link>
            </para>
          </listItem>
          <listItem>
            <para>
              <link xlink:href="#oldValue">Getting the value of some property before it was changed</link>
            </para>
          </listItem>
          <listItem>
            <para>
              <link xlink:href="#currentValue">Getting current property value</link>
            </para>
          </listItem>
          <listItem>
            <para>
              <link xlink:href="#propertyChanged">Checking if a property changed its value since it was started to be tracked</link>
            </para>
          </listItem>
          <listItem>
            <para>
              <link xlink:href="#undo">How do I accept or undo changes</link>
            </para>
          </listItem>
          <listItem>
            <para>
              <link xlink:href="#collectionChanges">Tracking collection changes</link>
            </para>
          </listItem>
          <listItem>
            <para>
              <link xlink:href="#graph">Object graph changes</link>
            </para>
          </listItem>
          <listItem>
            <para>
              <link xlink:href="#observe">Observe property and collection changes</link>
            </para>
          </listItem>
          <listItem>
            <para>
              <link xlink:href="#dynamic">Track dynamic objects</link>
            </para>
          </listItem>
          <listItem>
            <para>
              <link xlink:href="#metadata">Useful metadata</link>
            </para>
          </listItem>
          <listItem>
            <para>
              <link xlink:href="#test">Read the tests too</link>
            </para>
          </listItem>
        </list>
      </content>
    </section>

    <section address="objects2trackable">
      <title>How to turn objects into change-trackable ones</title>
      <content>
        <para>
          First of all, you need to design a regular class. <legacyBold>
            Note that the class must not be sealed and
            its properties must be <newTerm>virtual</newTerm> to let the proxy generator override them to intercept both
            sets and gets:
          </legacyBold>
        </para>
        <code language="c#">
          <![CDATA[
              public class User
              {
                public virtual string Name { get; set; }
                public virtual byte Age { get; set; }
              }
              ]]>
        </code>
        <para>
          Before being able to turn an object into a change-trackable one, you will need to tell <token>projectName</token> that
          your class (i.e. <phrase>the type</phrase>) can be trackable:
        </para>
        <code language="c#">
          <![CDATA[
          IObjectChangeTrackingConfiguration config = ObjectChangeTracking.CreateConfiguration();
          config.TrackThisType<User>();]]>
        </code>
        <para>
          Above configuration will tell <tokenName>TrackerDog</tokenName> to track all property changes for the given type. <legacyBold>
            This can
            be harmful and it's advisable that you tell <tokenName>TrackerDog</tokenName> which properties you want to track for the given type:
          </legacyBold>
        </para>
        <code language="c#">
          <![CDATA[
          // This will avoid some overhead since TrackerDog won't need to intercept absolutely all
          // property changes
          IObjectChangeTrackingConfiguration config = ObjectChangeTracking.CreateConfiguration();
          
          config.TrackThisType<User>(t => t.IncludeProperties(u => u.Name, u => u.Age));
          ]]>
        </code>
        <para>
          Now, to track an instance of <codeInline>User</codeInline> you need to
          use <codeEntityReference>M:TrackerDog.ITrackableObjectFactory.CreateFrom``1(``0)</codeEntityReference> method after getting
          <codeEntityReference>T:TrackerDog.ITrackableObjectFactory</codeEntityReference>'s implementation calling <codeEntityReference>M:TrackerDog.ObjectChangeTracking.CreateConfiguration</codeEntityReference> method:
        </para>
        <code language="c#">
          <![CDATA[
              IObjectChangeTrackingConfiguration config = ObjectChangeTracking.CreateConfiguration();
              config.TrackThisType<User>();
              
              ITrackableObjectFactory trackableObjectFactory = config.CreateTrackableObjectFactory();
              
              User user = trackableObjectFactory.CreateFrom(new User());
              
              // or...
              User user = new User();
              user = trackableObjectFactory.CreateFrom(user);
              
              // Also you can create a trackable object from the type directly without requiring an instance:
              User user2 = trackableObjectFactory.CreateOf<User>();
              ]]>
        </code>
        <para>
          Note that you won't be able to create trackable objects using <codeEntityReference>M:TrackerDog.ITrackableObjectFactory.CreateFrom``1(``0)</codeEntityReference>
          extension method if the whole object type has no paramterless constructor. Either if it has both a parameterless constructor or a one with parameters, and you want to create a trackable
          object with constructor arguments, you'll need to use <codeEntityReference>M:TrackerDog.ITrackableObjectFactory.CreateOf``1(System.Object[])</codeEntityReference> method:
        </para>
        <code language="c#">
          <![CDATA[
            public class A 
            {
              public A() { }
              public A(int a, string b) { }
            }
            
            IObjectChangeTrackingConfiguration config = ObjectChangeTracking.CreateConfiguration();
            config.TrackThisType<A>();
              
            ITrackableObjectFactory trackableObjectFactory = config.CreateTrackableObjectFactory();
            
            A a1 = trackableObjectFactory.CreateFrom(new A()); // Regular way
            A a2 = trackacbleObjectFactory.CreateOf<A>(); // From type with parameterless constructor
            A a3 = trackacbleObjectFactory.CreateOf<A>(101, "hello world"); // From type with constructor which has parameters
          ]]>
        </code>
        <para>Now you can produce changes to the trackable object:</para>
        <code language="c#">
          <![CDATA[
            user.Name = "Matías";
            user.Age = 30;
            ]]>
        </code>
      </content>
    </section>

    <section address="inheritance">
      <title>How to track inheritance</title>
      <content>
        <para>
          <token>projectName</token> can track inherited properties from a given type, but all base types must be configured separately. That is,
          members from base classes in the inheritance tree will be taken in account too when tracking for property changes:
        </para>
        <code language="c#">
          <![CDATA[
          public class A
          {
               public virtual string Text { get; set; }
          }
          
          public class B : A
          {
               public virtual string Name { get; set; }
          }
          
          IObjectChangeTrackingConfiguration config = ObjectChangeTracking.CreateConfiguration();
          config.TrackThisType<A>();
          config.TrackThisType<B>();
          ]]>
        </code>
        <alert class="important">
          <para>A given type to track properties must be configured for the type where the whole properties are declared.</para>
          <para>
            If you take last code sample as example, you will not configure <codeInline>A.Text</codeInline> on <codeInline>B</codeInline>
          </para>
        </alert>
      </content>
    </section>

    <section address="assemblyConfiguration">
      <title>Configuring all types from a given assembly</title>
      <content>
        <para>
          Perhaps your project is getting bigger and configuring each type manually to be change-trackable can be extremely tedious, or you just want
          to simplify configuration code. No problem: TrackerDog can configure all types from a given assembly using two methods:
        </para>
        <list class="bullet">
          <listItem>
            <para>
              <codeEntityReference qualifyHint="true">M:TrackerDog.Configuration.IObjectChangeTrackingConfiguration.TrackTypesFromAssembly(System.String,System.Action{TrackerDog.Configuration.IConfigurableTrackableType},TrackerDog.Configuration.TypeSearchSettings)</codeEntityReference>
            </para>
          </listItem>
          <listItem>
            <para>
              <codeEntityReference qualifyHint="true">M:TrackerDog.Configuration.IObjectChangeTrackingConfiguration.TrackTypesFromAssembly(System.Reflection.Assembly,System.Action{TrackerDog.Configuration.IConfigurableTrackableType},TrackerDog.Configuration.TypeSearchSettings)</codeEntityReference>
            </para>
          </listItem>
        </list>
        <para>And this is a sample usage:</para>
        <code language="c#">
          <![CDATA[
        IObjectChangeTrackingConfiguration config = ObjectChangeTracking.CreateConfiguration();
        config.TrackTypesFromAssembly("MyAssemblyName");
        config.TrackTypesFromAssembly(Assembly.GetExecutingAssembly());
        ]]>
        </code>
        <para>
          While this saves a lot of time and makes things even simpler, it might happen that you need to customize the underlying configuration process some way.
        </para>
        <para>Above goal can be achieved the second and/or third parameter on both mentioned methods:</para>

        <table>
          <tableHeader>
            <row>
              <entry>
                <para>Parameter</para>
              </entry>
              <entry>
                <para>Description</para>
              </entry>
            </row>
          </tableHeader>
          <row>
            <entry>
              <para>configure</para>
            </entry>
            <entry>
              <para>
                It is a delegate that will be called for each type being configured. The whole delegate receives a <codeEntityReference>T:TrackerDog.Configuration.IConfigurableTrackableType</codeEntityReference> implementation instance that should be enough to customize how the specific type will be tracked for changes.
              </para>
            </entry>
          </row>
          <row>
            <entry>
              <para>
                searchSettings
              </para>
            </entry>
            <entry>
              <para>
                It accepts a <codeEntityReference>T:TrackerDog.Configuration.TypeSearchSettings</codeEntityReference> instance. It provides extra information
                and behavior to configure how the whole methods will search for type and configure them as trackable types.
              </para>
            </entry>
          </row>
        </table>
      </content>
    </section>

    <section address="attributeConfiguration">
      <title>Attribute-based configuration</title>
      <content>
        <para>
          In addition to manually-configuring everything, you can mark certain types and their properties with attributes, and these will allow
          <token>projectName</token> to configure them as change-trackable types.
        </para>
        <para>
          Any type that should be change-trackable configured by attribute configuration will need the <codeEntityReference>T:TrackerDog.Configuration.ChangeTrackableAttribute</codeEntityReference> attribute:
        </para>
        <code language="c#">
          <![CDATA[
          [ChangeTrackable]
          public class A
          {
              public virtual string Text { get; set; }
              public virtual int Number { get; set; }
          }
          ]]>
        </code>
        <para>
          Above code sample would mean that all properties should be included in the change-tracking process. Otherwise, you need to specify which ones should
          be change-tracked with the same attribute:
        </para>
        <code language="c#">
          <![CDATA[
          [ChangeTrackable]
          public class A
          {
              [ChangeTrackable]
              public virtual string Text { get; set; }

              public virtual int Number { get; set; }
          }
          ]]>
        </code>
        <para>
          Last code listing above would mean that <codeInline>Number</codeInline> property must not be tracked. This is like a <phrase>white list</phrase>. If you want to specify which ones
          should not be tracked, it can be done with the <codeEntityReference>T:TrackerDog.Configuration.DoNotTrackChangesAttribute</codeEntityReference> attribute
        </para>
        <code language="c#">
          <![CDATA[
          [ChangeTrackable]
          public class A
          {
              public virtual string Text { get; set; }

              [DoNotTrackChanges]
              public virtual int Number { get; set; }
          }
          ]]>
        </code>
        <para>
          In the other hand, there are some rules to understand how these attributes work:
        </para>

        <list class="bullet">
          <listItem>
            <para>
              If a type has been marked with <codeInline>[ChangeTrackable]</codeInline> and properties aren't marked with any of mentioned attributes, then, all properties are trackable
            </para>
          </listItem>
          <listItem>
            <para>
              If a type has been marked with <codeInline>[ChangeTrackable]</codeInline> and one or more properties have been marked with <codeInline>[ChangeTrackable]</codeInline>, only those with the whole attribute
              will be tracked.
            </para>
          </listItem>
          <listItem>
            <para>
              If a type has been marked with <codeInline>[ChangeTrackable]</codeInline> and one or more properties have been marked with <codeInline>[DoNotTrackChanges]</codeInline>, those with or without <codeInline>[ChangeTrackable]</codeInline> will be tracked.
            </para>
          </listItem>
        </list>

        <para>
          <token>projectName</token>'s default behavior is to configure types with and without attributes, but you can override this behavior in certain conditions when calling the following methods:
        </para>
        <list class="bullet">
          <listItem>
            <para>
              <codeEntityReference>M:TrackerDog.Configuration.IObjectChangeTrackingConfiguration.TrackTypesFromAssembly(System.String,System.Action{TrackerDog.Configuration.IConfigurableTrackableType},TrackerDog.Configuration.TypeSearchSettings)</codeEntityReference>
            </para>
          </listItem>
          <listItem>
            <para>
              <codeEntityReference>M:TrackerDog.Configuration.IObjectChangeTrackingConfiguration.TrackTypesFromAssembly(System.Reflection.Assembly,System.Action{TrackerDog.Configuration.IConfigurableTrackableType},TrackerDog.Configuration.TypeSearchSettings)</codeEntityReference>
            </para>
          </listItem>
          <listItem>
            <para>
              <codeEntityReference>M:TrackerDog.Configuration.IObjectChangeTrackingConfiguration.TrackThisTypeRecursive(System.Type,System.Action{TrackerDog.Configuration.IConfigurableTrackableType},TrackerDog.Configuration.TypeSearchSettings)</codeEntityReference>
            </para>
          </listItem>
          <listItem>
            <para>
              <codeEntityReference>M:TrackerDog.Configuration.IObjectChangeTrackingConfiguration.TrackThisTypeRecursive``1(System.Action{TrackerDog.Configuration.IConfigurableTrackableType},TrackerDog.Configuration.TypeSearchSettings)</codeEntityReference>
            </para>
          </listItem>
        </list>

        <para>
          All above listed methods accept an argument of type <codeEntityReference>T:TrackerDog.Configuration.TypeSearchSettings</codeEntityReference> and an instance of the whole search settings
          can set <codeEntityReference>P:TrackerDog.Configuration.TypeSearchSettings.Mode</codeEntityReference> property to <codeEntityReference>F:TrackerDog.Configuration.TypeSearchMode.AttributeConfigurationOnly</codeEntityReference> which
          exactly meant to do restrict configuration to attribute-based one only.
        </para>

        <para>
          This configuration approach is even more friendly <link xlink:href="#assemblyConfiguration">when configuring types for an entire assembly</link>!
        </para>
      </content>
    </section>

    <section address="recursiveConfiguration">
      <title>Recursively-configuring trackable types</title>
      <content>
        <para>
          Configuring types that must be trackable can be a boring task. If you have found that you do not need to customize which properties to track
          on each type to track, maybe you have a lucky day: <token>projectName</token> can configure types recursively using <codeEntityReference qualifyHint="true">M:TrackerDog.Configuration.IObjectChangeTrackingConfiguration.TrackThisTypeRecursive``1(System.Action{TrackerDog.Configuration.IConfigurableTrackableType},System.Func{System.Type,System.Boolean})</codeEntityReference> and
          <codeEntityReference qualifyHint="true">M:TrackerDog.Configuration.IObjectChangeTrackingConfiguration.TrackThisTypeRecursive(System.Type,System.Action{TrackerDog.Configuration.IConfigurableTrackableType},System.Func{System.Type,System.Boolean})</codeEntityReference> methods.
        </para>
        <para>See following code listing:</para>
        <code language="c#">
          <![CDATA[
          public class A
          {
              public virtual B { get; set; }
          }
          
          public class B
          {
              public virtual C { get; set; }
          }
          
          public class C
          {
              public virtual B B { get; set; }
          }
          ]]>
        </code>
        <para>
          Instead of configuring each type separately, now you can configure <codeInline>A</codeInline> and the rest will be done auto-magically:
        </para>
        <code language="c#">
          <![CDATA[
          IObjectChangeTrackingConfiguration config = ObjectChangeTracking.CreateConfiguration();
          // This will also configure B and C
          config.TrackThisTypeRecursive<A>();
          ]]>
        </code>
        <para>
          Are you looking for customizing how each type is configured? It is still possible, but since <token>projectName</token> does not know the types to configure
          until run-time, configuration gets worse because you cannot use expression trees but reflection:
        </para>
        <code language="c#">
          <![CDATA[
          IObjectChangeTrackingConfiguration config = ObjectChangeTracking.CreateConfiguration();
          config.TrackThisTypeRecursive<A>
          (
              configure: t =>
              {
                  if(t.Type = typeof(A)) 
                  {
                      t.IncludeProperties(t.Type.GetProperty("Text"), t.Type.GetProperty("B"));
                  }
                  else if(t.Type == typeof(B))
                  {
                      t.IncludeProperty(t.Type.GetProperty("C"));
                  }
                  // ...and so on
              }
          );
          ]]>
        </code>
        <para>
          Also, there is a third parameter of the whole method that can filter which types to track during the recursive configuration:
        </para>
        <code language="c#">
          <![CDATA[
          IObjectChangeTrackingConfiguration config = ObjectChangeTracking.CreateConfiguration();
          config.TrackThisTypeRecursive<A>
          (
              configure: t =>
              {
                  if(t.Type = typeof(A)) 
                  {
                      t.IncludeProperties(t.Type.GetProperty("Text"), t.Type.GetProperty("B"));
                  }
                  else if(t.Type == typeof(B))
                  {
                      t.IncludeProperty(t.Type.GetProperty("C"));
                  }
                  // ...and so on
              },
              // You want A, B, C and other types will not be configured! You can invent any valid filter based on the type that
              // must or must not be configured!
              filter: t => new [] { "A", "B", "C" }.Contains(t.Name)
          );
          ]]>
        </code>
        <para>
          The whole filter can be provided with or without the configure action. If you just want to filter types based on some convention, it is fine to
          provide the filter and no other parameter.
        </para>
      </content>
    </section>

    <section address="trackingInterfaces">
      <title>How to track interface implementation changes</title>
      <content>
        <para>
          In some cases, you will need to track changes of types that are unknown but you already know that there will be types that implement a given
          interface. Imagine that you want to track property changes of properties part of some interface:
        </para>
        <code language="c#">
          <![CDATA[
          public interface IWhatever
          {
              string Text { get; set; }
          }
          ]]>
        </code>
        <para>
          Now you can track <phrase>the unknown</phrase>! Let's configure <codeInline>IWhatever</codeInline>:
        </para>
        <code language="c#">
          <![CDATA[
          IObjectChangeTrackingConfiguration config = ObjectChangeTracking.CreateConfiguration();
          config.TrackThisType<IWhatever>();
          ]]>
        </code>
        <para>
          Interface implementation change tracking will behave slightly different than classes, because <token>projectName</token> will auto-magically
          configure these interface implementations and also all associations/aggregates that may be defined in the whole interface. For example, let's
          improve the <codeInline>IWhatever</codeInline> interface:
        </para>
        <code language="c#">
          <![CDATA[
          public class Person
          {
               public virtual string Name { get; set; }
          }
          
          public interface IWhatever
          {
              string Text { get; set; }
              Person Person { get; set; }
          }
          
          IObjectChangeTrackingConfiguration config = ObjectChangeTracking.CreateConfiguration();
          config.TrackThisType<IWhatever>();
          ]]>
        </code>
        <para>
          Tracking <codeInline>IWhatever</codeInline> will automatically configure <codeInline>Person</codeInline>, and if there would be
          other associations at any level, it would do it too.
        </para>
        <para>
          Finally, interface tracking configuration can also define which properties to track like the rest of the cases:
        </para>
        <code language="c#">
          <![CDATA[
          IObjectChangeTrackingConfiguration config = ObjectChangeTracking.CreateConfiguration();
          config.TrackThisType<IWhatever>(t => t.IncludeProperties(w => w.Text, w => w.Person));
          ]]>
        </code>
      </content>
    </section>

    <section address="objects2untrackable">
      <title>How to turn trackable objects into untrackable objects</title>
      <content>
        <para>
          Sometimes, once an object has been tracked for changes for a while, some layer may need to get the object
          with latest property values but the object itself may not be change-trackable anymore.
        </para>
        <para>
          A good use case for this is <newTerm>serialization</newTerm>. When serializing a trackable object, resulting
          serialization will contain not just source object properties but also change-tracking internal ones, and this can be
          very dangerous. In fact, since <token>projectName</token> uses <phrase>Castle DynamicProxy</phrase>, serialized proxies
          will not be able to be deserialized because proxy requires some run-time details that will be available only when the object
          was created in memory
        </para>
        <para>
          Turning an object to <newTerm>untrackable</newTerm> requires a call to <codeEntityReference>M:TrackerDog.ObjectChangeTrackingExtensions.ToUntracked``1(``0)</codeEntityReference>:
        </para>
        <code language="c#">
          <![CDATA[
          User untrackedUser = user.ToUntracked();
          ]]>
        </code>
        <para>
          Calling the whole method not only will untrack the target object but also any association, including collections and its items.
        </para>
        <para>
          In the other hand, it's possible to get an untracked version of some collection directly calling <codeEntityReference>M:TrackerDog.ObjectChangeTrackingExtensions.ToUntrackedEnumerable(System.Collections.IEnumerable,System.Type)</codeEntityReference>:
        </para>
        <code language="c#">
          <![CDATA[
          public class A
          {
          }
          
          public class B
          {
              public virtual List<A> ListOfA { get; set; } = new List<A>();
          }
          
          IObjectChangeTrackingConfiguration config = ObjectChangeTracking.CreateConfiguration();
          config.TrackThisType<A>()
                .TrackThisType<B>();
              
          ITrackableObjectFactory trackableObjectFactory = config.CreateTrackableObjectFactory();
          
          B b = trackableObjectFactory.CreateFrom(new B());
          
          IList<A> list = b.ListOfA.ToUntrackedEnumerable(typeof(IList<>));
          ]]>
        </code>
        <alert class="note">
          <para>
            The whole method to convert a collection to an untracked one requires a type, where the
            type is a collection type that must be configured. <link xlink:href="1e03762d-b9f5-44af-a4b0-c23c36064c24#configuration">Follow this link to learn more.</link>
          </para>
        </alert>
      </content>
    </section>

    <section address="changedPropertyChecking">
      <title>Checking which properties have been changed</title>
      <content>
        <para>
          Call <codeEntityReference>M:TrackerDog.ObjectChangeTrackingExtensions.GetChangeTracker(System.Object)</codeEntityReference> extension method:
        </para>
        <code language="c#">
          <![CDATA[
            IObjectChangeTracker changeTracker = user.GetChangeTracker();
            
            IImmutableSet<IObjectPropertyChangeTracking> changedProperties = changeTracker.ChangedProperties;
            
            // Also you can get unchanged properties
            IImmutableSet<IObjectPropertyChangeTracking> unchangedProperties = changeTracker.UnchangedProperties;
            ]]>
        </code>
        <para>
          This will give sets of changed and unchanged properties typed as <codeEntityReference>T:TrackerDog.IObjectPropertyChangeTracking</codeEntityReference>. Mostly this
          is fine, but the whole interface exposes the affected property as string. If you need further info to perform reflection operations, you should cast set elements to
          <codeEntityReference>T:TrackerDog.IDeclaredObjectPropertyChangeTracking</codeEntityReference>:
        </para>
        <code language="c#">
          <![CDATA[
          IEnumerable<IObjectPropertyChangeTracking> changedProperties = changeTracker.ChangedProperties.OfType<IDeclaredObjectPropertyChangeTracking>();
            
          // Also you can get unchanged properties
          IEnumerable<IObjectPropertyChangeTracking> unchangedProperties = changeTracker.UnchangedProperties.OfType<IDeclaredObjectPropertyChangeTracking>();
          ]]>
        </code>
        <para>
          Now you'll be able to access <codeEntityReference>P:TrackerDog.IDeclaredObjectPropertyChangeTracking.Property</codeEntityReference>.
        </para>
        <para>
          Since <codeEntityReference>T:TrackerDog.IDeclaredObjectPropertyChangeTracking</codeEntityReference> also implements <codeEntityReference>T:TrackerDog.IObjectPropertyChangeTracking</codeEntityReference>, unless
          you need the property info of tracked property, there's no need to perform the whole cast.
        </para>
      </content>
    </section>

    <section address="oldValue">
      <title>Getting the value of some property before it was changed</title>
      <content>
        <para>
          Call <codeEntityReference>M:TrackerDog.ObjectChangeTrackingExtensions.OldPropertyValue``2(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}})</codeEntityReference> extension method:
        </para>
        <code language="c#">
          <![CDATA[
            string oldUserName = user.OldPropertyValue(u => u.Name);
            
            // You can also get a property tracking object
            IObjectChangeTracking userNameChangeTracking = user.GetPropertyTracking(u => u.Name);
            
            oldUserName = userNameChangeTracking.OldValue;
            ]]>
        </code>
      </content>
    </section>

    <section address="currentValue">
      <title>Getting current property value</title>
      <content>
        <para>
          Call <codeEntityReference>M:TrackerDog.ObjectChangeTrackingExtensions.CurrentPropertyValue``2(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}})</codeEntityReference> extension method:
        </para>
        <code language="c#">
          <![CDATA[
            string currentUserName = user.CurrentPropertyValue(u => u.Name);
            
            // Ok, you would also be able to achieve the same result doing so:
            currentUserName = user.Name;
            
            // But having this method lets you build an expression tree to select some tracked property "current value"...
            
            // You can also get a property tracking object
            IObjectChangeTracking userNameChangeTracking = user.GetPropertyTracking(u => u.Name);
            
            currentUserName = userNameChangeTracking.CurrentValue;
            ]]>
        </code>
      </content>
    </section>

    <section address="propertyChanged">
      <title>Checking if a property changed its value since it was started to be tracked</title>
      <content>
        <para>
          Call <codeEntityReference>M:TrackerDog.ObjectChangeTrackingExtensions.PropertyHasChanged``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Object}})</codeEntityReference> extension method:
        </para>
        <code language="c#">
          <![CDATA[
            if(user.PropertyHasChanged(u => u.Name))
            {
                // It has changed!
            }
            
            // You can also get a property tracking object
            IObjectChangeTracking userNameChangeTracking = user.GetPropertyTracking(u => u.Name);
            
            if(userNameChangeTracking.HasChanged)
            {
                // It has changed!
            }
            ]]>
        </code>
      </content>
    </section>

    <section address="undo">
      <title>How do I accept or undo changes</title>
      <content>
        <para>
          Call
          <codeEntityReference>M:TrackerDog.ObjectChangeTrackingExtensions.AcceptChanges(System.Object)</codeEntityReference> or
          <codeEntityReference>M:TrackerDog.ObjectChangeTrackingExtensions.UndoChanges(System.Object)</codeEntityReference> extension methods:
        </para>
        <code language="c#">
          <![CDATA[
            user.AcceptChanges();
            
            // or...
            user.UndoChanges();
            ]]>
        </code>
      </content>
    </section>

    <section address="collectionChanges">
      <title>Tracking collection changes</title>
      <content>
        <para>
          <token>projectName</token> supports tracking collection changes (i.e. it can observe collection changes). See the following
          code snippet to see how to use collection change tracking (if you want to know how to customize this feature please jump to <link xlink:href="1e03762d-b9f5-44af-a4b0-c23c36064c24" />):
        </para>
        <code language="c#">
          <![CDATA[
          public class App 
          {
              public virtual List<User> Users { get; } = new List<User>();
          }
          
          public class User 
          {
              public string Name { get; set; }
              public byte Age { get; set; }
          }
          
          IObjectChangeTrackingConfiguration config = ObjectChangeTracking.CreateConfiguration();
          config.TrackThisType<App>(t => t.IncludeProperty(app => app.Users))
                .TrackThisType<User>(t => t.IncludeProperties(u => u.Name, u => u.Age));
              
          ITrackableObjectFactory trackableObjectFactory = config.CreateTrackableObjectFactory();
          
          App app = trackableObjectFactory.CreateFrom(new App());
          app.Users.Add(new User { Name = "Matías", Age = 30 });
          
          IReadOnlyChangeTrackableCollection trackableCollection =
                        (IReadOnlyChangeTrackableCollection)app.CurrentPropertyValue(app => app.Users);
                        
          IImmutableSet<object> addedItems = trackableCollection.AddedItems;
          IImmutableSet<object> removedItems = trackableCollection.RemovedItems;
          
          // If you need typed items...
          IEnumerable<User> typedAddedUsers = addedItems.Cast<User>();
          IEnumerable<User> typedRemovedUsers = removedItems.Cast<User>();
          ]]>
        </code>
        <para>
          It might happen that you need to initialize some collection change tracking. For example, you want to consider
          changes after some other ones. Therefore, you would use <codeEntityReference>M:TrackerDog.CollectionExtensions.ClearChanges``1(System.Collections.Generic.ICollection{``0})</codeEntityReference>:
        </para>
        <code language="c#">
          <![CDATA[
          App app = trackableObjectFactory.CreateOf<App>();
          app.Users.Add(new User { Name = "Matías", Age = 30 });
          
          app.Users.ClearChanges();
          
          // Now TrackerDog will only know about this new user on App.Users
          app.Users.Add(new User { Name = "John", Age = 50 });
          ]]>
        </code>
      </content>
    </section>

    <section address="graph">
      <title>Object graph changes</title>
      <content>
        <para>
          When an aggregate root has many associations like 1-n, 1-1 or even M-N, <token>projectName</token>
          works the same way as a POCO with no associations with other objects:
        </para>
        <code language="c#">
          <![CDATA[
          public class A
          {
              public virtual string Text { get; set; }
              public virtual B B { get; set; }
          }

          public class B
          {
              public virtual string Text { get; set; }
              public virtual C C { get; set; }
          }

          public class C
          {
              public virtual string Text { get; set; }
              public virtual IList<D> ListOfD { get; set; }
          }

          public class D
          {
              public virtual string Text { get; set; }
          }          
          
          IObjectChangeTrackingConfiguration config = ObjectChangeTracking.CreateConfiguration();
          config.TrackThisType<A>(t => t.IncludeProperties(a => a.Text, a => a.B))
                .TrackThisType<B>(t => t.IncludeProperties(b => b.Text, b => b.C))
                .TrackThisType<C>(t => t.IncludeProperties(c => c.Text, c => c.ListOfD))
                .TrackThisType<D>(t => t.IncludeProperty(d => d.Text));
              
          ITrackableObjectFactory trackableObjectFactory = config.CreateTrackableObjectFactory();
          
          // It will track the full object graph changes!
          A a = trackableObjectFactory.CreateFrom
          (
            new A
            {
              Text = initialValue,
              B = new B
              {
                  Text = initialValue,
                  C = new C
                  {
                      Text = initialValue,
                      ListOfD = new List<D> { new D { Text = "initialValue" } }
                  }
              }
            }
          );
          ]]>
        </code>
        <para>
          In addition, if you need to perform some action whenever some property changes, you can bind
          an handler to <codeEntityReference qualifyHint="true">E:TrackerDog.IObjectChangeTracker.Changed</codeEntityReference> event:
        </para>
        <code language="c#">
          <![CDATA[
            // Continuation of previous code sample...
            IObjectChangeTracker changeTracker = a.GetChangeTracker();
            changeTracker.Changed += (sender, e) => 
            {
                // Do stuff here whenever a property changes
            };
            
          ]]>
        </code>
        <para>
          The whole event will give you an instance of <codeEntityReference>T:TrackerDog.DeclaredObjectPropertyChangeEventArgs</codeEntityReference> event
          arguments, which will provide access to which property was changed, the target object that changed, and also an associated
          <codeEntityReference>T:TrackerDog.IObjectGraphTrackingInfo</codeEntityReference> implementation instance to introspect full aggregate/association hierarchy.
        </para>
      </content>
    </section>

    <section address="observe">
      <title>Observe property and collection changes</title>
      <content>
        <para>
          All change-tracked objects implement <codeEntityReference>T:System.ComponentModel.INotifyPropertyChanged</codeEntityReference> and
          change-tracked collection properties implement <codeEntityReference>T:System.Collections.Specialized.INotifyCollectionChanged</codeEntityReference>.

        </para>
        <para>
          Note that collection changes will also trigger a <codeEntityReference>E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged</codeEntityReference> event on the
          object in the other side of the 1-n association.

        </para>
        <code language="c#">
          <![CDATA[
          public class App 
          {
              public virtual string Name { get; set; }
              public List<User> Users { get; } = new List<User>();
          }
          
          public class User 
          {
              public virtual string Name { get; set; }
              public virtual byte Age { get; set; }
          }
          
          IObjectChangeTrackingConfiguration config = ObjectChangeTracking.CreateConfiguration();
          config.TrackThisType<App>(t => t.IncludeProperty(app => app.Users))
                .TrackThisType<User>(t => t.IncludeProperties(u => u.Name, u => u.Age));
              
          ITrackableObjectFactory trackableObjectFactory = config.CreateTrackableObjectFactory();
          
          App app = trackableObjectFactory.CreateFrom(new App());
          
          ((INotifyPropertyChanged)app).PropertyChanged += (sender, e) =>
          {
              string propertyName = e.PropertyName;
          };
          
          ((INotifyCollectionChanged)app.Users).CollectionChanged += (sender, e) =>
          {
              IEnumerable<object> changedItems = e.ChangedItems;
          };
          
          app.Name = "MyApp"; // This will trigger a PropertyChanged event on app
          
           // This will both trigger a CollectionChanged event on app.Users and a PropertyChanged event on
           // app.
          app.Users.Add(new User { Name = "Matías" });
          ]]>
        </code>
      </content>
    </section>

    <section>
      <title>Track dynamic objects</title>
      <content>
        <para>
          A dynamic object (i.e. a derived class of <codeEntityReference>T:System.Dynamic.DynamicObject</codeEntityReference>) can't be tracked
          <phrase>per se</phrase>. For example, <codeEntityReference>T:System.Dynamic.ExpandoObject</codeEntityReference> can't be tracked because
          it's a sealed class and either way its members aren't virtual.
        </para>
        <para>
          <token>projectName</token> supports dynamic objects but they must be non-sealed class and their members must be virtual. That is, <token>projectName</token>
          will be able to track custom dynamic objects. For example:
        </para>
        <code language="c#">
          <![CDATA[
          public class TestDynamicObject : DynamicObject
          {
              private string value;

              public override bool TryGetMember(GetMemberBinder binder, out object result)
              {
                  result = value;

                  return true;
              }

              public override bool TrySetMember(SetMemberBinder binder, object value)
              {
                  this.value = value?.ToString();
                  return true;
              }
          }
          ]]>
        </code>
        <para>
          Above class has no sense in a real-world case, since any try to set a member sets the same class field
          and whenever any member is tried to be got, it will return the last set value. But this sample dynamic object
          is a good enough to test that <token>projectName</token> can track dynamic objects:
        </para>
        <code language="c#">
          <![CDATA[
          IObjectChangeTrackingConfiguration config = ObjectChangeTracking.CreateConfiguration();
          config.TrackThisType<DynamicObject>());
              
          ITrackableObjectFactory trackableObjectFactory = config.CreateTrackableObjectFactory();
          
          dynamic trackable = trackableObjectFactory.CreateFrom(new TestDynamicObject());
          trackable.Text = "hello world";
          trackable.Text = "hello world2";
          ]]>
        </code>
        <para>
          Now the issue will be using <codeEntityReference>M:TrackerDog.ITrackableObjectFactory.CreateFrom``1(``0))</codeEntityReference> with a dynamic object.
          You'll need to cast the <literal>dynamic</literal>-typed variable into <literal>object</literal> to be able to call all object change tracking-related extension methods:
        </para>
        <code language="c#">
          <![CDATA[
          // Note that all extension methods that relate to dynamic objects will require
          // you to give the property name as string, because expression trees can't work with 
          // dynamic objects, and anyway, "Text" property doesn't exist since it's not declared but
          // dynamically-handled using DynamicObject.TryGetMemeber and DynamicObject.TrySetMember
          string currentTextValue = ((object)trackable).OldPropertyValue("Text");
          IObjectChangeTracker changeTracker ((object)trackable).GetChangeTracker();
          // ...and so on.
          ]]>
        </code>
        <para>
          When getting property trackings, there's a difference between <phrase>declared properties</phrase> and <phrase>dynamic properties</phrase>
        </para>
        <list class="bullet">
          <listItem>
            <para>
              ...when you want a tracking of a declared property (i.e. a design-time declared property), you'll get a <codeEntityReference>T:TrackerDog.IDeclaredObjectPropertyChangeTracking</codeEntityReference>, and it
              will provide access you to the <codeEntityReference>P:TrackerDog.IDeclaredObjectPropertyChangeTracking.Property</codeEntityReference> which is of type <codeEntityReference>T:System.Reflection.PropertyInfo</codeEntityReference>.
            </para>
          </listItem>
          <listItem>
            <para>
              ...when you want a tracking of a dynamic property (i.e. a run-time added property), you'll get a <codeEntityReference>T:TrackerDog.IObjectPropertyChangeTracking</codeEntityReference>, and it
              will provide access you to the <codeEntityReference>P:TrackerDog.IObjectPropertyChangeTracking.PropertyName</codeEntityReference> which provides less info than a <codeEntityReference>T:System.Reflection.PropertyInfo</codeEntityReference> since
              the property belongs to the object where it was declared but <phrase>since it's not an actual property, you don't know more than just its name</phrase>.
            </para>
          </listItem>
        </list>
        <para>
          For example, if you want to get a dynamic property tracking, you would do as follows:
        </para>
        <code language="c#">
          <![CDATA[
          IObjectChangeTracker changeTracker ((object)trackable).GetChangeTracker();
          IObjectPropertyChangeTracking propertyTracking = tracker.GetDynamicTrackingByProperty("Text");
          ]]>
        </code>
      </content>
    </section>

    <section address="metadata">
      <title>Useful metadata</title>
      <content>
        <para>
          Once trackable types have been already configured, <token>projectName</token> can expose
          useful metadata that is being used internally but it can be also required outside of the
          project's code base.
        </para>
      </content>

      <sections>
        <section>
          <title>Object paths</title>
          <content>
            <para>
              Sometimes external tools and frameworks might require to know the full path to some
              property part of a given trackable type.
            </para>
            <para>
              For example, consider the following class hierarchy:
            </para>
            <code language="c#">
              <![CDATA[
              public class A
              {
                public string Text { get; set; }
                public B B { get; set; }
              }
              
              public class B
              {
                  public string Name { get; set; }
                  public C C { get; set; }
              } 
              
              public class C 
              {
                  public string Description { get; set; }
              }
              ]]>
            </code>
            <para>
              Once trackable types have been already configured, it's very easy to get a trackable type metadata:
            </para>
            <code language="c#">
              <![CDATA[
              IObjectChangeTrackingConfiguration config = ObjectChangeTracking.CreateConfiguration()
                                                                .TrackThisType<A>();
                                                                
              ITrackableType metadata = config.GetTrackableType(typeof(A));
              ]]>
            </code>
            <para>
              What if some project needs to know the path to <codeInline>C.Description</codeInline> property
              starting from <codeInline>A</codeInline> (i.e. <codeInline>A.B.C.Description)</codeInline>?
            </para>
            <para>
              No problem, because <codeEntityReference>T:TrackerDog.Configuration.ITrackableType</codeEntityReference> has an <codeEntityReference>P:TrackerDog.Configuration.ITrackableType.ObjectPaths</codeEntityReference> property
              which holds a collection of all properties of some given trackable type and its associations, and each property is represented
              by the <codeEntityReference>T:TrackerDog.IObjectPropertyInfo</codeEntityReference> interface, which has, for example, <codeEntityReference>P:TrackerDog.IObjectPropertyInfo.Path</codeEntityReference> property
              that gives the path to some particular property starting from the trackable type. For example, the so-called <codeInline>A.B.C.Description</codeInline>
            </para>
          </content>
        </section>
      </sections>
    </section>

    <section address="test">
      <title>Read the tests too</title>
      <content>
        <para>
          In addition to this tutorial, you might learn more reading the unit/integration tests provided as part
          of project's source code. You can also clone the repository in your own computer and run the whole tests using
          the Visual Studio debugger to check how <token>projectName</token> works step by step!
        </para>
        <list class="bullet">
          <listItem>
            <externalLink>
              <linkText>GitHub repository</linkText>
              <linkUri>https://github.com/mfidemraizer/trackerdog</linkUri>
            </externalLink>.
          </listItem>
          <listItem>
            <externalLink>
              <linkText>Tests source code</linkText>
              <linkUri>https://github.com/mfidemraizer/trackerdog/tree/master/TrackerDog.Test</linkUri>
            </externalLink>.
          </listItem>
        </list>
      </content>
    </section>

    <relatedTopics>
      <link xlink:href="1e03762d-b9f5-44af-a4b0-c23c36064c24" />
    </relatedTopics>
  </developerConceptualDocument>
</topic>